use anyhow::{Context, Result, bail};
use async_openai::types::{ChatCompletionRequestMessage, ChatCompletionRequestSystemMessageArgs};
use futures::stream::{FuturesUnordered, StreamExt};
use serde::{Deserialize, Serialize};

use super::{file::File, paths::ProjectPaths};
use crate::{
    config,
    java::grade::{
        LineRef,
        context::{build_active_retrieval_context, build_heuristic_context},
    },
    retrieval::{HeuristicConfig, RetrievalFormatter},
    util::find_files,
};
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
/// Struct representing a Java project.
/// Any index `i` in any collection in this struct always refers to the same
/// JavaFile.
pub struct Project {
    /// Collection of java files in this project
    files: Vec<File>,
    /// Cached list of proper names kept in lockstep with `files` so we can
    /// satisfy direct name lookups quickly. If we ever mutate the project
    /// contents after construction, prefer tightening this to an index map
    /// instead of maintaining parallel vectors.
    names: Vec<String>,
    /// Workspace paths associated with this project
    paths: ProjectPaths,
}

impl Project {
    /// Initializes a Project by discovering Java files in the workspace root
    /// and preparing metadata for later operations.
    pub fn new() -> Result<Self> {
        Self::from_paths(ProjectPaths::default())
    }

    /// Core implementation that discovers files for the provided paths.
    fn from_paths(paths: ProjectPaths) -> Result<Self> {
        let mut files = vec![];
        let mut names = vec![];

        let runtime = config::runtime();
        let handle = runtime.handle().clone();
        let paths_for_search = paths.clone();

        let discovered_files = handle.block_on(async move {
            let found_files =
                find_files("java", 15, paths_for_search.root_dir()).with_context(|| {
                    format!(
                        "Could not discover Java files under {}",
                        paths_for_search.root_dir().display()
                    )
                })?;

            let mut handles = FuturesUnordered::new();
            for path in found_files {
                let file_paths = paths_for_search.clone();
                handles.push(tokio::task::spawn_blocking(move || File::new(path, file_paths)));
            }

            let mut collected = Vec::new();
            while let Some(result) = handles.next().await {
                let file = result.context("A file discovery task panicked or was cancelled")??;
                collected.push(file);
            }

            Ok::<_, anyhow::Error>(collected)
        })?;

        for file in discovered_files {
            names.push(file.proper_name());
            files.push(file);
        }

        Ok(Self {
            files,
            names,
            paths,
        })
    }

    #[cfg(test)]
    pub(crate) fn from_paths_for_tests(paths: ProjectPaths) -> Result<Self> {
        Self::from_paths(paths)
    }

    /// Attempts to identify the correct file from the project from a partial or
    /// fully formed name as expected by a java compiler.
    ///
    /// Returns a reference to the identified file, if any.
    ///
    /// * `name`: partial/fully formed name of the Java file to look for.
    pub fn identify(&self, name: &str) -> Result<File> {
        if let Some(index) = self.locate_index(name) {
            Ok(self.files[index].clone())
        } else {
            bail!("Could not find {} in the project", name)
        }
    }

    /// Returns true if project contains a file with the given name.
    pub fn contains(&self, name: &str) -> bool {
        self.locate_index(name).is_some()
    }

    /// Returns the workspace paths associated with this project.
    pub fn paths(&self) -> &ProjectPaths {
        &self.paths
    }

    /// Get a reference to the project's files.
    pub fn files(&self) -> &[File] {
        self.files.as_ref()
    }

    /// Prints project struct as a json
    pub fn info(&self) -> Result<()> {
        println!("{}", serde_json::to_string(&self)?);
        Ok(())
    }

    /// Returns a short summary of the project, it's files, their fields and
    /// methods.
    pub fn describe(&self) -> String {
        let mut lines = vec!["<project>".to_string()];

        for file in self.files.iter() {
            // Hidden-test fixtures generated by ByHiddenTestGrader carry
            // "Hidden" in their proper name. Skip them so we don't include
            // instructor-only assets in the synthesized outline.
            if file.proper_name().contains("Hidden") {
                continue;
            }
            lines.push(file.description());
        }

        lines.push("</project>".to_string());
        lines.join("\n")
    }
}

impl Project {
    /// Attempts to locate the index of a file that matches the provided name.
    fn locate_index(&self, name: &str) -> Option<usize> {
        self.names
            .iter()
            .position(|n| n == name)
            .or_else(|| self.files.iter().position(|file| file.file_name() == name))
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.file_name().trim_end_matches(".java") == name)
            })
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.simple_name() == name)
            })
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.path().display().to_string() == name)
            })
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.proper_name() == name)
            })
    }
}

impl RetrievalFormatter for Project {
    fn language(&self) -> &'static str {
        "java"
    }

    fn full_codebase(&self) -> Result<Vec<ChatCompletionRequestMessage>> {
        let mut blocks = Vec::new();
        for file in self.files.iter() {
            let language = "java";
            let header = format!(
                "<file name=\"{}\" path=\"{}\" language=\"{}\">",
                file.proper_name(),
                file.path().display(),
                language
            );
            let mut content = vec![header];
            content.push(String::from("```java"));
            content.push(file.code().to_string());
            content.push(String::from("```"));
            content.push(String::from("</file>"));

            blocks.push(
                ChatCompletionRequestSystemMessageArgs::default()
                    .content(content.join("\n"))
                    .name("Instructor".to_string())
                    .build()
                    .context("Failed to build full-codebase message")?
                    .into(),
            );
        }

        Ok(blocks)
    }

    fn heuristic_context(
        &self,
        line_refs: Vec<LineRef>,
        cfg: HeuristicConfig,
    ) -> Result<ChatCompletionRequestMessage> {
        build_heuristic_context(line_refs, self.clone(), cfg)
    }

    fn active_retrieval(&self, grader_output: String) -> Result<ChatCompletionRequestMessage> {
        build_active_retrieval_context(self, grader_output)
    }
}
