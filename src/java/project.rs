#![warn(missing_docs)]
#![warn(clippy::missing_docs_in_private_items)]

use anyhow::{Context, Result, anyhow};
use async_openai::types::chat::{
    ChatCompletionRequestMessage, ChatCompletionRequestSystemMessageArgs,
};
use bon::{builder, vec};
use serde::{Deserialize, Serialize};

use super::{file::File, paths::ProjectPaths};
use crate::{
    java::grade::{
        LineRef,
        context::{build_active_retrieval_context, build_heuristic_context},
    },
    retrieval::{HeuristicConfig, RetrievalFormatter},
    util::find_files,
};
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
/// Struct representing a Java project.
/// Any index `i` in any collection in this struct always refers to the same
/// JavaFile.
pub struct Project {
    /// Collection of java files in this project
    files: Vec<File>,
    /// Cached list of proper names kept in lockstep with `files` so we can
    /// satisfy direct name lookups quickly. If we ever mutate the project
    /// contents after construction, prefer tightening this to an index map
    /// instead of maintaining parallel vectors.
    names: Vec<String>,
    /// Workspace paths associated with this project
    paths: ProjectPaths,
}

impl Project {
    /// Initializes a Project by discovering Java files in the workspace root
    /// and preparing metadata for later operations.
    pub fn new() -> Result<Self> {
        Self::from_paths(ProjectPaths::default())
    }

    /// Core implementation that discovers files for the provided paths.
    fn from_paths(paths: ProjectPaths) -> Result<Self> {
        // TODO: When a typed Project builder lands, surface custom workspace layouts
        // instead of hard-coding defaults.
        let mut files = vec![];
        let mut names = vec![];

        let found_files = find_files("java", 15, paths.root_dir()).with_context(|| {
            format!("Could not discover Java files under {}", paths.root_dir().display())
        })?;

        for path in found_files {
            let display_path = path.display().to_string();
            let file = File::new(path, paths.clone())
                .with_context(|| format!("Failed to load {}", display_path))?;
            names.push(file.proper_name());
            files.push(file);
        }

        Ok(Self {
            files,
            names,
            paths,
        })
    }

    /// Attempts to identify the correct file from the project from a partial or
    /// fully formed name as expected by a java compiler.
    ///
    /// Returns a reference to the identified file, if any.
    ///
    /// * `name`: partial/fully formed name of the Java file to look for.
    pub fn identify(&self, name: &str) -> Result<File> {
        let Some(index) = self.match_index(name) else {
            return Err(anyhow!("Could not find {} in the project", name));
        };
        Ok(self.files[index].clone())
    }

    /// Returns true if project contains a file with the given name.
    pub fn contains(&self, name: &str) -> bool {
        self.match_index(name).is_some()
    }

    /// Returns the workspace paths associated with this project.
    pub fn paths(&self) -> &ProjectPaths {
        &self.paths
    }

    /// Get a reference to the project's files.
    pub fn files(&self) -> &[File] {
        self.files.as_ref()
    }

    /// Prints project struct as a json
    pub fn info(&self) -> Result<()> {
        // Keep the same shape but use pretty JSON so humans can read it more easily.
        println!("{}", serde_json::to_string_pretty(&self)?);
        Ok(())
    }

    /// Returns a short summary of the project, it's files, their fields and
    /// methods.
    pub fn describe(&self) -> String {
        let mut lines = vec!["<project>"];

        for file in self.files.iter() {
            // Hidden-test fixtures generated by ByHiddenTestGrader carry
            // "Hidden" in their proper name. Skip them so we don't include
            // instructor-only assets in the synthesized outline.
            if file.proper_name().contains("Hidden") {
                continue;
            }
            lines.push(file.description());
        }

        lines.push("</project>".to_string());
        lines.join("\n")
    }
}

impl Project {
    /// Attempts to locate the index of a file that matches the provided name.
    fn match_index(&self, name: &str) -> Option<usize> {
        self.names
            .iter()
            .position(|n| n == name)
            .or_else(|| self.files.iter().position(|file| file.file_name() == name))
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.file_name().trim_end_matches(".java") == name)
            })
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.simple_name() == name)
            })
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.path().display().to_string() == name)
            })
            .or_else(|| {
                self.files
                    .iter()
                    .position(|file| file.proper_name() == name)
            })
    }
}

impl RetrievalFormatter for Project {
    fn language(&self) -> &'static str {
        "java"
    }

    fn full_codebase(&self) -> Result<Vec<ChatCompletionRequestMessage>> {
        let mut blocks = Vec::new();
        for file in self.files.iter() {
            let language = "java";
            let header = format!(
                "<file name=\"{}\" path=\"{}\" language=\"{}\">",
                file.proper_name(),
                file.path().display(),
                language
            );
            let mut content = vec![header];
            content.push(String::from("```java"));
            content.push(file.code().to_string());
            content.push(String::from("```"));
            content.push(String::from("</file>"));

            blocks.push(
                ChatCompletionRequestSystemMessageArgs::default()
                    .content(content.join("\n"))
                    .name("Instructor".to_string())
                    .build()
                    .context("Failed to build full-codebase message")?
                    .into(),
            );
        }

        Ok(blocks)
    }

    fn heuristic_context(
        &self,
        line_refs: Vec<LineRef>,
        cfg: HeuristicConfig,
    ) -> Result<ChatCompletionRequestMessage> {
        build_heuristic_context(line_refs, self.clone(), cfg)
    }

    fn active_retrieval(&self, grader_output: String) -> Result<ChatCompletionRequestMessage> {
        build_active_retrieval_context(self, grader_output)
    }
}

/// Builder-style entry point for constructing a Project with optional custom
/// paths.
#[builder(finish_fn = build)]
pub fn project(paths: Option<ProjectPaths>) -> Result<Project> {
    let paths = paths.unwrap_or_default();
    Project::from_paths(paths)
}
